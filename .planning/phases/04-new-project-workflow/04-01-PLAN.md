---
phase: 04-new-project-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/project-init.js
  - workflows/gsd/gsd-new-project.md
autonomous: true

must_haves:
  truths:
    - "writeProjectMd() creates a populated PROJECT.md from gathered context"
    - "writeConfigJson() creates config.json with user preferences merged onto upstream defaults"
    - "/gsd-new-project.md workflow guides user through conversational questioning"
    - "Workflow commits artifacts incrementally after each file creation"
  artifacts:
    - path: "src/project-init.js"
      provides: "writeProjectMd, writeConfigJson helper functions"
      exports: ["writeProjectMd", "writeConfigJson"]
    - path: "workflows/gsd/gsd-new-project.md"
      provides: "Full new-project workflow for Cline"
      contains: "deep questioning"
  key_links:
    - from: "workflows/gsd/gsd-new-project.md"
      to: "src/project-init.js"
      via: "node -e import for file generation"
      pattern: "project-init"
    - from: "src/project-init.js"
      to: "src/state-init.js"
      via: "uses ensurePlanningDir and ensurePhaseDir"
      pattern: "state-init"
---

<objective>
Create the project initialization helper module and new-project workflow.

Purpose: Enable users to start new GSD projects by typing `/gsd-new-project.md` in Cline, which guides them through conversational questioning and generates PROJECT.md, config.json, REQUIREMENTS.md, ROADMAP.md, and STATE.md with populated content.

Output: `src/project-init.js` (Node.js helper functions) and `workflows/gsd/gsd-new-project.md` (Cline workflow file)
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-new-project-workflow/04-RESEARCH.md

@src/state-init.js
@src/state-read.js
@src/state-write.js
@workflows/gsd/gsd-health.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project-init.js helper module</name>
  <files>src/project-init.js</files>
  <action>
Create `src/project-init.js` with two exported functions following the project's error-return pattern (`{ success, data, error }`):

**`writeProjectMd(planningDir, project)`**
- Accepts `planningDir` (string, path to .planning/) and `project` object with fields: `name`, `description`, `coreValue`, `context`, `constraints` (string[]), `requirements` (optional object with `validated`, `active`, `outOfScope` arrays), `keyDecisions` (optional array of {decision, rationale, outcome}), `date` (optional, defaults to today)
- Generates PROJECT.md matching the template structure in `state-init.js` but with ALL sections populated from the `project` object instead of placeholder text
- Sections: What This Is, Core Value, Requirements (Validated/Active/Out of Scope), Context, Constraints, Key Decisions table
- Returns `{ success: true, data: { path } }` or `{ success: false, error }`

**`writeConfigJson(planningDir, preferences)`**
- Accepts `planningDir` and `preferences` object with optional fields: `mode` ('yolo'|'interactive'), `depth` ('quick'|'standard'|'comprehensive'), `parallelization` (boolean), `commit_docs` (boolean), `model_profile` ('quality'|'balanced'|'budget'), `workflow` (object), `planning` (object), `gates` (object), `safety` (object)
- Starts from full upstream defaults (same as `configTemplate()` in state-init.js): mode='yolo', depth='comprehensive', workflow={research:true, plan_check:true, verifier:true}, planning={max_tasks_per_plan:8, require_verification:true, require_tests:false}, parallelization=true, commit_docs=true, model_profile='quality', gates={plan_review:false, checkpoint_approval:true}, safety={backup_before_execute:false, dry_run_first:false}
- Overlays user preferences: for nested objects, shallow-merge (spread defaults then user values); for scalars, direct replace
- Writes JSON with 2-space indent + trailing newline
- Returns `{ success: true, data: { path } }` or `{ success: false, error }`

Use ESM imports (`import { writeFile } from 'node:fs/promises'` etc.). Do NOT import from state-init.js -- keep this module self-contained to avoid circular dependency risk. The default config values are duplicated intentionally (same as how state-read.js duplicates them for defaults merging).

Include JSDoc for both functions. Follow the same code style as state-init.js (arrow-free, explicit returns, descriptive variable names).
  </action>
  <verify>
Run: `node -e "import { writeProjectMd, writeConfigJson } from './src/project-init.js'; console.log('imports OK');"` from project root -- should print "imports OK" with no errors.

Run: `node -e "
import { writeProjectMd, writeConfigJson } from './src/project-init.js';
import { mkdtemp, readFile, rm } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import path from 'node:path';

const tmp = await mkdtemp(path.join(tmpdir(), 'gsd-test-'));
const r1 = await writeProjectMd(tmp, {
  name: 'Test Project',
  description: 'A test project for verification.',
  coreValue: 'Verify project-init works',
  context: 'Testing phase 4 plan 01',
  constraints: ['Node 20+', 'ESM only']
});
console.log('writeProjectMd:', r1.success);
const content = await readFile(path.join(tmp, 'PROJECT.md'), 'utf-8');
console.log('has core value:', content.includes('Verify project-init works'));

const r2 = await writeConfigJson(tmp, { mode: 'interactive', depth: 'quick' });
console.log('writeConfigJson:', r2.success);
const cfg = JSON.parse(await readFile(path.join(tmp, 'config.json'), 'utf-8'));
console.log('mode override:', cfg.mode === 'interactive');
console.log('depth override:', cfg.depth === 'quick');
console.log('has defaults:', cfg.parallelization === true && cfg.commit_docs === true);

await rm(tmp, { recursive: true });
"` -- all lines should print true.
  </verify>
  <done>
Both `writeProjectMd` and `writeConfigJson` export correctly, generate files with populated content, and merge preferences onto defaults correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gsd-new-project.md workflow</name>
  <files>workflows/gsd/gsd-new-project.md</files>
  <action>
Create `workflows/gsd/gsd-new-project.md` -- a Cline workflow file that guides the AI through the full new-project initialization flow. This is a prompt injection file (Cline injects its contents as `<explicit_instructions>` when user types `/gsd-new-project.md`).

**Structure** -- use YAML frontmatter + markdown with step-based instructions:

```yaml
---
description: Initialize a new GSD project with deep questioning and structured output
---
```

**Steps (10 phases matching upstream GSD flow):**

**Step 1: Check existing project**
- Run `test -d .planning && echo "exists" || echo "new"` via Bash
- If `.planning/` exists, warn user: "A project already exists. Use `/gsd-progress.md` to check status, or confirm you want to start fresh (this will overwrite existing planning files)."
- If user confirms fresh start, continue. Otherwise stop.

**Step 2: Initialize git**
- Run `git rev-parse --is-inside-work-tree 2>/dev/null || git init`
- Ensure project has git before we start committing artifacts

**Step 3: Detect brownfield project**
- Check for common code indicators: `package.json`, `requirements.txt`, `Cargo.toml`, `go.mod`, `pom.xml`, `*.sln`, `src/` directory
- If code exists, inform user: "I see an existing codebase. After project setup, consider running `/gsd-map-codebase.md` to analyze it."
- This is informational only -- continue regardless

**Step 4: Deep questioning**
- Start with: "What do you want to build?"
- Follow the user's energy. Dig into what they emphasize. Challenge vague answers.
- Use concrete alternatives to probe: "When you say X, do you mean A or B?"
- Surface hidden assumptions: "Who will use this?", "What does done look like?"
- Sufficiency criteria -- you have enough when you know: (1) what they're building, (2) why it matters, (3) who it's for, (4) what "done" looks like, (5) key constraints
- This typically takes 3-6 exchanges. Don't rush, but don't over-question.
- The tone is "thinking partner, not interviewer" -- follow-up questions should build on previous answers, not jump to new topics

**Step 5: Create PROJECT.md**
- Using all gathered context, create `.planning/PROJECT.md` with populated sections
- The AI can either use the Write tool directly OR invoke the Node.js helper via Bash: `node -e "import { writeProjectMd } from './src/project-init.js'; ..."` (whichever produces better output for the specific project)
- Commit immediately: `git add .planning/PROJECT.md && git commit -m "docs: create PROJECT.md via /gsd-new-project"`

**Step 6: Workflow preferences**
- Ask the user about their preferred workflow settings (present as natural questions, not a form):
  - Mode: "Do you want to approve each step, or should I go full speed?" (yolo/interactive)
  - Depth: "How thorough should planning be? Quick for simple projects, comprehensive for complex ones." (quick/standard/comprehensive)
  - Parallelization: "Should I use parallel agents for research tasks?" (yes/no)
  - Commit docs: "Should planning files be tracked in git?" (yes/no)
- Can ask these as 1-2 grouped questions, not one at a time

**Step 7: Create config.json**
- Generate `.planning/config.json` with user preferences merged onto defaults
- Use the Node.js helper: `node -e "import { writeConfigJson } from './src/project-init.js'; const result = await writeConfigJson('.planning', { mode: '...', depth: '...' }); console.log(JSON.stringify(result));"`
- Or write directly with the Write tool
- Commit: `git add .planning/config.json && git commit -m "docs: create config.json via /gsd-new-project"`

**Step 8: Define requirements**
- Based on the questioning, generate `.planning/REQUIREMENTS.md` with:
  - Requirement IDs (e.g., REQ-01, REQ-02) for each validated requirement
  - Requirements grouped by functional area (not just a flat list)
  - Out of scope section with reasons
  - Traceability table (to be filled during planning)
- Commit: `git add .planning/REQUIREMENTS.md && git commit -m "docs: create REQUIREMENTS.md via /gsd-new-project"`

**Step 9: Create roadmap**
- Based on requirements, propose a phased roadmap (typically 4-8 phases)
- Each phase has: Goal, Dependencies, Requirements it addresses, Success Criteria
- Create `.planning/ROADMAP.md` with full phase structure
- Create progress table at the bottom
- Commit: `git add .planning/ROADMAP.md && git commit -m "docs: create ROADMAP.md via /gsd-new-project"`

**Step 10: Initialize STATE.md and wrap up**
- Create `.planning/STATE.md` with current position set to Phase 1, Plan 0
- Create `.planning/phases/` directory
- Commit: `git add .planning/STATE.md && git commit -m "docs: create STATE.md via /gsd-new-project"`
- Present summary of what was created
- Suggest next step: "Run `/gsd-progress.md` to see your project status, or start planning Phase 1."

**Key behavioral instructions for the AI:**
- You are a thinking partner, not an interviewer
- Follow energy -- whatever the user emphasized, dig into that
- Challenge vagueness -- never accept fuzzy answers
- Know when to stop -- when you understand what/why/who/done, offer to proceed
- Each file creation is followed by an immediate git commit (crash resilience)
- If any step fails, report the error clearly and suggest how to fix it
- Do NOT ask the user to manually create files -- use Write tool or Bash

Keep the workflow to approximately 150-200 lines. It needs to be comprehensive but not so long that it overwhelms Cline's context. Focus on clear behavioral instructions rather than verbose explanations.
  </action>
  <verify>
Verify the workflow file:
1. `test -f workflows/gsd/gsd-new-project.md && echo "exists"` -- should print "exists"
2. Check YAML frontmatter: `head -3 workflows/gsd/gsd-new-project.md` -- should show `---`, `description:`, `---`
3. Check all 10 steps are present: grep for "Step 1" through "Step 10" or equivalent section headers
4. Check key behavioral instructions are included: grep for "thinking partner" or "follow energy"
5. Check git commit instructions are present: grep for "git commit" -- should find multiple occurrences (one per artifact)
6. Check brownfield detection: grep for "package.json" or "brownfield"
7. Check questioning sufficiency criteria: grep for "enough" or "sufficiency"
  </verify>
  <done>
`workflows/gsd/gsd-new-project.md` exists with YAML frontmatter, covers all 10 upstream GSD phases (check existing, init git, brownfield detect, questioning, PROJECT.md, preferences, config.json, requirements, roadmap, STATE.md), includes atomic git commits after each artifact, and contains clear behavioral instructions for conversational questioning.
  </done>
</task>

</tasks>

<verification>
1. `node -e "import { writeProjectMd, writeConfigJson } from './src/project-init.js'; console.log('OK');"` -- imports work
2. `test -f workflows/gsd/gsd-new-project.md` -- workflow file exists
3. `grep -c 'git commit' workflows/gsd/gsd-new-project.md` -- multiple commit instructions (at least 4)
4. `grep -l 'description:' workflows/gsd/gsd-new-project.md` -- has YAML frontmatter
</verification>

<success_criteria>
- `src/project-init.js` exports `writeProjectMd` and `writeConfigJson` with error-return pattern
- `writeProjectMd` generates a fully populated PROJECT.md (not skeleton/placeholder)
- `writeConfigJson` merges user preferences onto full upstream defaults
- `workflows/gsd/gsd-new-project.md` is a complete Cline workflow with all 10 steps
- Workflow includes atomic git commits after each artifact creation
- Workflow questioning follows "thinking partner" methodology with sufficiency criteria
</success_criteria>

<output>
After completion, create `.planning/phases/04-new-project-workflow/04-01-SUMMARY.md`
</output>
